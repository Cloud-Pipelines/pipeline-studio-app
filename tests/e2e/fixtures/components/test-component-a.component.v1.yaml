name: Test component {NAME_PLACEHOLDER}
metadata:
  annotations:
    cloud_pipelines.net: "true"
    components new regenerate python-function-component: "true"
    python_original_code_path: src/test-component-a.py
    python_original_code: |
      #!/usr/bin/env python3
      def test_component_a(input_string: str, mode: str = "standard") -> str:
          import logging
          import os
          import sys

          """Test component A. Version {VERSION_PLACEHOLDER}.

          Args:
              input_string: The string to process
              mode: Processing mode - either "debug" or "standard" (default: "standard")

          Returns:
              A transformed version of the input string based on the mode
          """
          # Validate mode
          if mode not in ["debug", "standard"]:
              raise ValueError(f"Invalid mode: '{mode}'. Must be 'debug' or 'standard'")

          # Set up logging
          logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s", stream=sys.stdout)
          logger = logging.getLogger(__name__)

          # Log the input
          logger.info(f"Processing input: '{input_string}' in {mode} mode")

          # Log some environment variables (only in debug mode)
          if mode == "debug":
              logger.info("=== Environment Variables ===")
              env_vars = ["USER", "HOME", "SHELL", "PWD", "LANG", "PATH"]
              for var in env_vars:
                  value = os.environ.get(var)
                  if value:
                      if var == "PATH":
                          # PATH can be very long, just show count
                          logger.info(f"{var}: {len(value.split(':'))} paths")
                      else:
                          logger.info(f"{var}: {value}")
              logger.info(f"Total environment variables: {len(os.environ)}")

          # Transform the string
          stripped = input_string.strip()
          reversed_str = stripped[::-1]
          uppercase = stripped.upper()
          word_count = len(stripped.split())
          char_count = len(stripped)

          # Create result based on mode
          if mode == "debug":
              # Debug mode: return detailed information
              result = (
                  f"[DEBUG] Original: '{stripped}' | "
                  f"Reversed: '{reversed_str}' | "
                  f"Uppercase: '{uppercase}' | "
                  f"Words: {word_count}, Chars: {char_count} | "
                  f"Env vars: {len(os.environ)}"
              )
          elif mode == "standard":
              # Standard mode: return simplified information
              result = f"Processed: '{uppercase}' ({word_count} words)"
          else:
              raise ValueError(f"Invalid mode: '{mode}'. Must be 'debug' or 'standard'")

          logger.info("Processing complete")

          return result
    component_yaml_path: src/test-component-a.component.yaml
    python_dependencies: '["google-cloud-bigquery==3.26.0", "google-cloud-bigquery-storage==2.29.1",
      "pyarrow==19.0.1", "pandas==2.2.1", "lightgbm==4.3.0", "numpy>=1.26.0", "setuptools==69.2.0",
      "scikit-learn==1.5.0", "comet-ml==3.49.10", "google-cloud-secret-manager==2.18.0",
      "urllib3<2.0.0", "db-dtypes>=1.3.1", "sympy>=1.12"]'
    git_relative_dir: .
    git_local_branch: main
    git_local_sha: e21f92f7e1f55102c97ea965272153f6f580e299
    git_remote_url: https://github.com/Shopify/shop-promise-modeling.git
    git_remote_branch: main
    git_remote_sha: c9d9d4f4cc2ecd5b025e9b06e050d1ed85cc5fc7
inputs:
- {name: input_string, type: String}
- {name: mode, type: String, default: standard, optional: true}
outputs:
- {name: Output, type: String}
implementation:
  container:
    image: us-docker.pkg.dev/shopify-docker-images/containers/apps/production/shop-promise-modeling:main
    command:
    - sh
    - -c
    - (PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet --no-warn-script-location
      'google-cloud-bigquery==3.26.0' 'google-cloud-bigquery-storage==2.29.1' 'pyarrow==19.0.1'
      'pandas==2.2.1' 'lightgbm==4.3.0' 'numpy>=1.26.0' 'setuptools==69.2.0' 'scikit-learn==1.5.0'
      'comet-ml==3.49.10' 'google-cloud-secret-manager==2.18.0' 'urllib3<2.0.0' 'db-dtypes>=1.3.1'
      'sympy>=1.12' || PIP_DISABLE_PIP_VERSION_CHECK=1 python3 -m pip install --quiet
      --no-warn-script-location 'google-cloud-bigquery==3.26.0' 'google-cloud-bigquery-storage==2.29.1'
      'pyarrow==19.0.1' 'pandas==2.2.1' 'lightgbm==4.3.0' 'numpy>=1.26.0' 'setuptools==69.2.0'
      'scikit-learn==1.5.0' 'comet-ml==3.49.10' 'google-cloud-secret-manager==2.18.0'
      'urllib3<2.0.0' 'db-dtypes>=1.3.1' 'sympy>=1.12' --user) && "$0" "$@"
    - sh
    - -ec
    - |
      program_path=$(mktemp)
      printf "%s" "$0" > "$program_path"
      python3 -u "$program_path" "$@"
    - |
      def test_component_a(input_string, mode = "standard"):
          import logging
          import os
          import sys

          """Test component A. Version 1.

          Args:
              input_string: The string to process
              mode: Processing mode - either "debug" or "standard" (default: "standard")

          Returns:
              A transformed version of the input string based on the mode
          """
          # Validate mode
          if mode not in ["debug", "standard"]:
              raise ValueError(f"Invalid mode: '{mode}'. Must be 'debug' or 'standard'")

          # Set up logging
          logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s", stream=sys.stdout)
          logger = logging.getLogger(__name__)

          # Log the input
          logger.info(f"Processing input: '{input_string}' in {mode} mode")

          # Log some environment variables (only in debug mode)
          if mode == "debug":
              logger.info("=== Environment Variables ===")
              env_vars = ["USER", "HOME", "SHELL", "PWD", "LANG", "PATH"]
              for var in env_vars:
                  value = os.environ.get(var)
                  if value:
                      if var == "PATH":
                          # PATH can be very long, just show count
                          logger.info(f"{var}: {len(value.split(':'))} paths")
                      else:
                          logger.info(f"{var}: {value}")
              logger.info(f"Total environment variables: {len(os.environ)}")

          # Transform the string
          stripped = input_string.strip()
          reversed_str = stripped[::-1]
          uppercase = stripped.upper()
          word_count = len(stripped.split())
          char_count = len(stripped)

          # Create result based on mode
          if mode == "debug":
              # Debug mode: return detailed information
              result = (
                  f"[DEBUG] Original: '{stripped}' | "
                  f"Reversed: '{reversed_str}' | "
                  f"Uppercase: '{uppercase}' | "
                  f"Words: {word_count}, Chars: {char_count} | "
                  f"Env vars: {len(os.environ)}"
              )
          elif mode == "standard":
              # Standard mode: return simplified information
              result = f"Processed: '{uppercase}' ({word_count} words)"
          else:
              raise ValueError(f"Invalid mode: '{mode}'. Must be 'debug' or 'standard'")

          logger.info("Processing complete")

          return result

      def _serialize_str(str_value: str) -> str:
          if not isinstance(str_value, str):
              raise TypeError('Value "{}" has type "{}" instead of str.'.format(str(str_value), str(type(str_value))))
          return str_value

      import argparse
      _parser = argparse.ArgumentParser(prog='Test component a', description='')
      _parser.add_argument("--input-string", dest="input_string", type=str, required=True, default=argparse.SUPPRESS)
      _parser.add_argument("--mode", dest="mode", type=str, required=False, default=argparse.SUPPRESS)
      _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
      _parsed_args = vars(_parser.parse_args())
      _output_files = _parsed_args.pop("_output_paths", [])

      _outputs = test_component_a(**_parsed_args)

      _outputs = [_outputs]

      _output_serializers = [
          _serialize_str,

      ]

      import os
      for idx, output_file in enumerate(_output_files):
          try:
              os.makedirs(os.path.dirname(output_file))
          except OSError:
              pass
          with open(output_file, "w") as f:
              f.write(_output_serializers[idx](_outputs[idx]))
    args:
    - --input-string
    - {inputValue: input_string}
    - if:
        cond: {isPresent: mode}
        then:
        - --mode
        - {inputValue: mode}
    - '----output-paths'
    - {outputPath: Output}
